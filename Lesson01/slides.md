---
theme: seriph
title: Linux 概念及基础教程
class: text-center
transition: slide-left
mdc: true
overviewSnapshots: true
---

#  Linux 概念及基础教程

软件研发部 运维组

---

# 为什么要使用 Linux ?

- 喜欢折腾
- 想要成为黑客！
- 想要深层次的学习计算机/操作系统原理
- 厌倦了 windows 的反人类设计
- 想要为开源软件做贡献 :)

## Or： 

- 需要配置各种开发环境
- 专业软件不支持 windows

*事实上，可以认为世界上的 90% 的设备都运行在 Linux 上*  

<!--
智能手机¶

智能手机目前有两个主流的操作系统：苹果公司研发的 iOS 操作系统和谷歌公司研发的 Android 操作系统，而 Android 正是 Linux 的一个知名的发行版。与通常安装在通用计算机上的 GNU/Linux 分支不同，Android 属于 Android/Linux 分支，这个分支通常活跃在智能手机和嵌入式设备的舞台上。

由谷歌公司推出的 Android 叫做 Android 原生系统，而基于该原生系统诞生出来的各类独特的操作系统就是 Android/Linux 系下的子发行版。Android/Linux 下的子发行版很多，如华为公司的 EMUI 操作系统和小米公司的 MIUI 操作系统等。

服务器¶

现代人的生活已经很难离开互联网了，在互联网上，我们可以访问各式各样的网站、利用在线社交平台分享自己的生活、或者是使用联机办公工具和同事协同工作。通常来说这些网站和软件的提供商都需要设立他们自己的计算机来完成计算、存储和通信的功能，这种计算机就被称为服务器。和个人计算机不同，服务器通常都不会使用 Windows 或者 macOS 这种个人计算机操作系统，事实上绝大部分的服务器维护人员都愿意选择一些 Linux 发行版作为它们的操作系统，因为许多 Linux 发行版界面简洁，功能强大，而且某些发行版也是受到专业计算机企业的服务支持的（如前文提到的 RHEL）。

同时，受惠于互联网上丰富的教程，Debian 和 Ubuntu Server 也成为越来越多个人和团体用作服务器操作系统的 Linux 发行版，如下文提到的中科大开源社群 LUG@USTC 使用 Debian 发行版及其衍生产品 Proxmox VE 作为其所有服务器的操作系统。

另一类有名的服务器操作系统是微软公司的 Windows Server 系列，不过其流行程度比不上各类 Linux 发行版。
-->

---
layout: quote
---

# Linux 历史

- Unix Family / BSD Family
- GNU - GNU is Not Unix (Richard Stallman)

1991 年，正在大学内进修的林纳斯·托瓦兹对他使用的一个类 UNIX 操作系统 MINIX 十分不满，
因为当时 MINIX 仅可用于教育但不允许任何商业用途。  
于是他在他的大学时期编写并发布了自己的操作系统，
也就是后来所谓的 “Linux 内核”，成为了如今各类 Linux 发行版的基础。  

<!--
计算机的更新换代¶

自 1946 年第一台通用计算机埃尼阿克（全称“电子数值积分计算机”，英文简称 ENIAC）问世以来，人类文明就朝向信息化大步迈进。在接下来的几十年，计算机经历了真空管时代（第一代，ENIAC 就是真空管计算机）、晶体管时代（第二代，如贝尔实验室的世界上第一台全晶体管计算机 TRADIC）、集成电路时代（第三代，如 IBM System / 360 系列）和如今的大规模集成电路时代（第四代，如世界上第一款微处理器 Intel 4004）。在更新换代中，计算机的性能和集成度都有着飞跃般的提升，在过去几十年的表现呈指数级增长，因而就有了计算机行业内耳熟能详的“摩尔定律”，即集成电路上可容纳的晶体管数目每两年就会翻一倍，这条定律描述了近几十年来计算机性能爆发增长的现象。 
-->

---
layout: center
---

# Unix/Linux 哲学

- Do one thing, and do it well.
- Everything is a file.
- Keep it Simple, Stupid.

<!--
1、模块原则：写简单的程序，并用好的接口连接它们

    编程的核心是控制复杂度。Brian Kernighan

开发一个项目的绝大部分时间都用来Debug了，所以完成一个项目更多是因为能够控制好Debug的时间和复杂程度。只有一种办法可以有效的控制复杂度：作出简单的子系统，然后用精心设计的接口把他们连接成一个应用。
2、清晰原则：清楚透明的算法比“高明”的算法更好

维护系统的成本非常高，在写程序的时候就应该首先注意程序的可读性，而不是效率。因为，归根结底这些程序是留给其他程序员或者开发者本身阅读的。

实践这个原则包括：良好的注释，简单明了的算法。注释的功能容易理解，简单明了的算法则是因为通常简单的算法更加容易维护且不容易出问题。所以，在性能允许的情况下，尽量选择简单易懂的算法。

    永远不要超过三次靠努力思考才能看懂一段代码。第一次可能是侥幸看懂了，但是如果你发现过了一段时间你又需要重新思考一遍才能看懂这段代码，因为你忘了上一次是怎么想的了，这时候你应该注释掉这段代码，这样你就不会第三次为了这段代码发愁了。
3、组装原则，Composition：写能够跟其他程序一起工作的程序

如果你写的代码不能够互相交流，不能相互组合，那么你的代码很快就会成长成一个难以维护的巨大怪物。因此Unix的编程传统鼓励写输入、输出基于文本的程序，很多Unix程序其实就是一个简单的Filter，输入一串字符，输入另一串字符。

从实践的角度，在我们写程序的时候尽量使用简单的字符作为接口，而不是复杂的二进制文件，甚至GUI。

4、简单原则，Simplicity：尽量简化算法，不到必要的时候不要增加复杂度

Unix的工程实践形成了这样一种文化：更加欢迎简单的解法，更加注重把系统分解成小的部分。
5、简约原则，Parsimony：只要在必要的时候才写大型程序，通常小程序已经足够

如果程序变得越来越大，就会渐渐失去可维护性。
6、透明原则，Transparency：写容易测试和纠错的代码

写出“透明”的程序至少需要如下两个特性：程序非常直观容易理解；程序有清晰的内部状态并且可以打印，比如日志。

写出“透明”的应用需要在上面的基础上，增加一个特性：使用简单的接口。
-->

---

# 什么是操作系统?

- 运行在最底层，负责为上层应用提供接口（服务）的软件
- 负责多个应用的进程管理、硬件设备（cpu、ram、硬盘等等）的资源管理
- 负责管理应用安全权限
- ...

## Linux 设计特点

<br>

- 代码简洁，可移植性高
- 开放源代码
- 原生支持多用户
- 结构化的文件系统
- ...

<!--
计算机操作系统¶

如果现在提起计算机操作系统，可能多数人的第一反应就是大名鼎鼎的 Windows，此外有些人可能也接触过 macOS 或者 Linux 的各类发行版（如：Ubuntu, Manjaro, CentOS 等），它们都是计算机操作系统。然而计算机最初并没有操作系统。在当时，许多计算机不是通用计算机，它们造出来就是为了某个特定目的而服务的，因此其架构只需要为这个目的而设计即可，无需包括完整的操作系统。另外一个原因是在晶体管时代之前，计算机体积庞大，而性能又十分有限，因此也没有能力承载通用的操作系统。随着计算机性能的提升，人们更加依赖计算机的能力，对计算机的功能要求也日渐复杂。为了能尽可能利用计算机的自动化这一特性，一些操作系统开始成型。在成型的初期，计算机操作系统的目的是为了帮助用户进行批处理操作，不过之后它们也慢慢有了新的功能：进程管理、任务调度、控制输入输出设备等。这样的操作系统逐渐形成了庞大的体系，成为了联络一般用户和计算机底层设备的中介，让用户无需关心绝大多数的底层设备，大大降低了用户的使用学习成本。

现代操作系统的功能 *¶

现代的计算机操作系统的功能已经十分复杂，远非当初所能比，且不同的操作系统可能在各方面都有着差异。但总体来说，其一直是用户与底层硬件交流的桥梁。用户可以通过操作系统的用户界面向计算机发出命令，操作系统则对输入的命令进行解释并驱动相关的设备来实现用户的要求。
现代个人计算机操作系统典型功能

不同的操作系统通常会基于不同设计思路，面向不同的用户群体，因此从用户的使用感受来说往往大相径庭。然而由于现代个人计算机操作系统的功能高度相似，因此它们在不同的外表下存在着诸多共通的属性。只要进行一些调研，我们就能发现它们实际上殊途同归。
-->

---
layout: quote
---

# Windows vs. Linux

内在复杂度 vs. 外在复杂度  
习惯 Linux 操作后，你会感觉到 windows 是多么难用  
在使用的过程中，你会不可避免的遇到各种问题，
但是在解决这些问题的过程中，你会更加深入的理解操作系统及计算机的原理...  

---

# Linux 组成

内核 + shell + 文件系统 + 各种软件包

<Transform :scale="0.73">
<img
border="rounded"
src="/linux.png"
alt=""
/>
</Transform>

<!--
Linux操作系统体系架构及原理

 

Linux系统一般有4个主要部分：内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用

系统。

内核的接口被称为系统调用(system call)，公用函数库建立在系统调用接口上，应用程序既可使用公用函数库，也可使用系统调用。

shell 是一个特殊的应用程序，为运行其他应用程序提供了一个接口。

从广义上说，操作系统包括了内核和一些其他软件，这些软件使得计算机能够发挥作用，并使计算机具有自己的特性。

这里所说的其他软件包括系统实用程序(system utility)、应用程序、shell 以及公用函数库等。

一、内核

内核是操作系统的核心，具有很多最基本功能，如虚拟内存、多任务、共享库、需求加载、可执行程序和TCP/IP网络功能。Linux内核的模块分为以下几个部分：存储管

理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等。

1、内存管理

2、进程管理

3、文件系统

4、设备管理与驱动

Linux内核子系统

5、网络接口

提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP

协议是 Internet  的标准协议，同时也是事实上的工业标准。Linux  的网络实现支持 BSD 套接字，支持全部的TCP/IP协议。Linux内核的网络部分由BSD套接字、网络协

议层和网络设备驱动程序组成。网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。

 二、shell

shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通

编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。
-->

---

# Linux 组成

内核 + shell + 文件系统 + 各种软件包

<Transform :scale="0.7">
<img
border="rounded"
src="/arch.png"
alt=""
/>
</Transform>

---

# Linux 下的目录结构 （FHS）

Linux 下不根据磁盘来划分文件目录，而是把所有磁盘都挂载到了同一个目录下，
并依照统一的标准划分文件。  

<Transform :scale="0.7">
<img
border="rounded"
src="/fhs.jpg"
alt=""
/>
</Transform>

<!--
文件系统层次结构¶

相信到现在你应该已经发现了：Linux 下文件系统的结构和 Windows 的很不一样。在 Windows 中，分区以盘符的形式来标识（如「C 盘」、「D 盘」），各个分区的分界线是很明确的。在系统所在的分区（一般为 C 盘）中，存储着程序文件 (Program Files)，系统运行需要的文件 (Windows)，用户文件 (Users) 等。这种组织形式源于 DOS 和早期的 Windows，并一直传承下来。

而 UNIX 系列采用了一种不一样的思路组织文件：整个系统的文件都从 /（根目录）开始，像一棵树一样，类似于下图。

其他的分区以挂载 (mount) 的形式「挂」在了这棵树

那么在根目录下的这些目录各自有什么含义呢？这就由文件系统层次结构标准 (FHS, Filesystem Hierarchy Standard) 来定义了。这个标准定义了 Linux 发行版的标准目录结构。大部分的 Linux 发行版遵循此标准，或由此标准做了细小的调整。以下进行一个简要的介绍。也可以在官网查看标准的具体内容。

当然，实际情况不一定会和以下介绍的内容完全一致。可以使用 man hier 和 man file-hierarchy 查看你的系统中关于文件系统层次结构的文档。  

/bin  
    存储必须的程序文件，对所有用户都可用。  
/boot  
    存储在启动系统时需要的文件。  
/dev  
    存储设备文件。

    什么是设备文件？

    在 Linux 的哲学中，存在着「一切皆文件」这样的思想。设备文件就是计算机设备抽象成文件的形式，程序和用户可以以读写普通文件的方式向这些文件输入内容，或者从文件中获取内容。系统驱动程序会相应处理用户对对应设备文件的输入和输出。

    有一些常用的设备文件如：

        /dev/null：总是返回空（EOF）数据。
        /dev/zero：总是返回零数据。
        /dev/urandom：输出随机数据。

    配合第六章中提到的重定向功能，这些设备文件可以帮助我们做到丢弃程序输出等操作。
/etc

    存储系统和程序的配置文件。

    注册表与配置文件

    Windows 系统与其上很多程序都使用注册表，而非文件的形式存储配置信息。注册表是一个数据库，拥有数据库的优点（如原子性），集中地管理配置项。而 Linux 下的程序更喜欢将配置以文件的形式存储，保持配置简单，便于用户编辑与备份。

    当然，这不是绝对的。现在 Windows 下的 .NET 程序更偏向于将配置存储在 XML 文件中，而 Linux 下的 GNOME 桌面环境也采取了类似于注册表的形式: GConf，存储自己的配置信息。
/home

    用户的家目录。存储用户自己的信息。
/lib

    存放系统运行必须的程序库文件。
/media 和 /mnt

    这两个目录都用于挂载其他的文件系统。/media 用于可移除的文件系统（如光盘），而 /mnt 用于临时使用。
/opt

    存放额外的程序包。一般将一些大型的、商业的应用程序放置在这个目录。
/root

    root 用户的家目录。
/run

    系统运行时的数据。在每次启动时，里面的数据都会被删除。
/sbin

    存储用于系统管理，以及仅允许 root 用户使用的程序。如 fsck（文件系统修复程序）、reboot（重启系统）等。
/srv

    存储网络服务的数据。
/tmp
    临时目录，所有用户都可使用。
/usr （unix software resource）

    大多数软件都会安装在此处。其下有一些目录与 / 下的结构相似，如：

        /usr/bin
        /usr/lib
        /usr/sbin

    此外，还有一些目录：

        /usr/include: 存储系统通用的 C 头文件。当然，里面会有你非常熟悉的头文件，如 stdio.h。
        /usr/local: 存储系统管理员自己安装的程序，这些文件不受系统的软件管理机制（如 apt）控制。/usr/local 里面的层次结构和 /usr 相似。
        /usr/share: 存储程序的数据文件（如 man 文档、GUI 程序使用的图片等）。

    usrmerge

    近年来，部分发行版选择将 /usr/bin、/usr/sbin、/usr/lib 与根目录下的 /bin、/sbin、/lib 合并，根目录下的对应目录软链接到 /usr 下的目录，以简化文件结构。

    Ubuntu 与 Debian 中可以安装 usrmerge 软件包来进行转换。
/var

    存储会发生变化的程序相关文件。例如下面的目录：

        /var/log：存储程序的日志文件。
        /var/lib：存储程序自身的状态信息（如 lock file）。
        /var/run：存储程序运行时的数据（部分发行版会将该目录符号链接到 /run 目录）。
        /var/spool：存储「等待进一步处理」的程序数据。
-->

---
layout: quote
---

# 一切皆文件

将操作系统的 IO 操作抽象成文件操作  

万物皆可读写 ？  

从终端、打印机到鼠标、键盘，所有设备都被抽象成了一个文件

<!--
一切皆文件

“一切皆是文件”是 Unix/Linux 的基本哲学之一，它是指 Linux 系统中的所有的一切都可以通过文件的方式访问、管理，即使不是文件，也以文件的形式来管理。例如硬件设备、进程、套接字等都抽象成文件，使用统一的用户接口，虽然文件类型各不相同，但是对其提供的却是同一套操作。

这里的一切是单向的，也即所有的东西都单向通过文件系统呈现，反向不一定可行。比如通过新建文件的方式来创建磁盘设备是行不通的。

提示

不准确但是形象的例子

Linux 系统把硬件设备映射成文件，例如将摄像头映射为 /dev/video，然后就可以使用基本的函数操作它。用 open() 函数连接设备，再用 read() 函数读取图像，最后用 write() 函数保存图像。

而在声卡设备中，read() 函数会变为录音功能，write() 函数变为播放功能。


一切皆文件的实际好处

"Linux系统一切皆文件"这个设计哲学带来了许多实际的好处，让我们来看看其中几个：

1. 简化权限管理

在Linux系统中，文件和目录都有相应的权限，如读、写、执行等。通过使用文件系统的权限机制，可以更方便地管理用户对设备、进程和其他资源的访问权限。这种统一的权限管理机制让管理员更加容易配置和控制用户的权限，提高了系统的安全性。

2. 统一的接口和编程风格

"一切皆文件"的设计哲学使得Linux系统提供了统一的接口，无论是硬件设备、进程信息还是网络接口，都可以使用相同的文件I/O接口进行访问和操作。这样的设计简化了系统编程，减少了编程的复杂性。开发人员可以通过简单的文件I/O接口来访问各种资源，而不需要特定的API和驱动程序。

3. 易于扩展和定制

由于Linux系统一切皆文件的设计思想，任何新的资源或设备只需要在文件系统中创建对应的设备文件，就可以通过标准的文件I/O接口来访问和操作。这使得Linux系统非常灵活和易于扩展。同时，用户也可以根据自己的需求创建自定义的设备文件，实现个性化的功能。
-->

---
layout: quote
---

# Linux 下的软件包

由于 Linux 下不同的软件包（模块）具有不同的依赖关系，  
所以需要一个工具（包管理器）来帮助你管理这些依赖  

- 千千万万的软件包组成了对应的依赖关系
- 各种软件包分而治之
- 一个模块只做一件事情 （DOADIW）
- 每个模块可维护可升级可演化

<!--
大多数现代的类 Unix 操作系统都提供了一种中心化的机制用来搜索和安装软件。软件通常都是存放在存储库中，并通过包的形式进行分发。处理包的工作被称为包管理。包提供了操作系统的基本组件，以及共享的库、应用程序、服务和文档。

包管理系统除了安装软件外，它还提供了工具来更新已经安装的包。包存储库有助于确保你的系统中使用的代码是经过审查的，并且软件的安装版本已经得到了开发人员和包维护人员的认可。

在配置服务器或开发环境时，我们最好了解下包在官方存储库之外的情况。某个发行版的稳定版本中的包有可能已经过时了，尤其是那些新的或者快速迭代的软件。然而，包管理无论对于系统管理员还是开发人员来说都是至关重要的技能，而已打包的软件对于主流 Linux 发行版来说也是一笔巨大的财富。
-->

---
layout: quote
---

# Linux Distribution

基于 Linux 内核，产生了许多有名的发行版  
一个典型的发行版包括：Linux 内核，GNU 库和各种系统工具，命令行 Shell，图形界面的 X 窗口和上层的桌面环境等。
桌面环境有如 KDE 或 GNOME 等，并包含数千种应用软件。  
而不同的发行版一般有不同的包管理器工具  

<br>

其中最著名的有 deb(apt) 和 rpm(yum/dnf) 系  

- deb 系： debian、ubuntu...
- rpm 系： centos、fedora、rocky...

前往[distrowatch](https://distrowatch.com/)了解更多  
Basically it's just same, go with anything you like.

<!--
Linux 发行版¶

一个典型的 Linux 发行版除了 Linux 内核以外，通常还会包括一系列 GNU 工具和库、一些附带的软件、说明文档、一个桌面系统、一个窗口管理器和一个桌面环境。不同的发行版之间除了 Linux 内核以外的其它部分都有可能不一样，因此有的时候我们对比某两种发行版的时候会觉得它们看起来像是完全不一样的操作系统，然而实质上它们却拥有着相同的核心，即 Linux 内核。

这里给读者介绍若干桌面和服务器环境中主流的发行版分支：
Debian 分支¶

Debian 是一个完全由自由软件构成的类 UNIX 操作系统，第一个版本发布于 1993 年 9 月 15 日，迄今仍在维护，是最早的发行版之一。其以坚持自由软件精神和生态环境优良而出名，拥有庞大的用户群体，甚至自己也成为了一个主流的子框架，称为“Debian GNU/Linux”。

Debian 图标

Debian GNU/Linux 也派生了很多发行版，其中最为著名的便是 Ubuntu（官方译名“友邦拓”）。Ubuntu 由英国的 Canonical 公司主导创立，是一个主打桌面应用的操作系统。其为一般用户提供了一个时新且稳定的由自由软件构成的操作系统，且拥有庞大的社群力量和资源，十分适合普通用户使用。

Ubuntu 图标
Red Hat 分支¶

Red Hat Linux 是美国的 Red Hat 公司发行的一个发行版，第一个版本发布于 1994 年 11 月 3 日，也是一个历史悠久的发行版。它曾经也广为使用，但在 2003 年 Red Hat 公司停止了对它的维护，转而将精力都投身于其企业版 Red Hat Enterprise Linux（简称 RHEL）上，Red Hat Linux 自此完结，而商业市场导向的 RHEL 维护至今。

Red Hat 公司商标，RHEL 是其旗下产品

在 Red Hat Linux 在停止官方更新后，由社群启动的 Fedora 项目接管了其源代码并构筑了自己的更新，演变成了如今的 Fedora 发行版。Fedora 是一套功能完备且更新迅速的系统，且本身计划也受到了 Red Hat 公司的赞助，成为了公司测试新技术的平台。

Fedora 图标

虽然 RHEL 是一个收费的、商业化的系统，但是其遵循 GNU 通用公共许可证，因此会开放源代码。编译这些源代码可以重新得到一个可以使用的操作系统，即一个新的发行版：CentOS（Community Enterprise Operating System，社区版企业操作系统）。因为 CentOS 几乎完全编译自 RHEL 的代码，所以其也像 RHEL 一样具有企业级别的稳定性，适合在要求高度稳定的服务器上运行。

2020 年 12 月，CentOS 社区在其博客中宣布未来的重点转向 CentOS Stream，这是一个全新的滚动发行版。在此之前，RHEL 的上游为 Fedora，而 CentOS 的上游为 RHEL；在推出 CentOS Stream 之后，它就成为了 RHEL 的上游发行版。与此同时，CentOS 8 的支持期限被缩短至 2021 年底，且不再推出新的非 Stream 的 CentOS 版本。不满于该决定的人们也组织了新的社区，推出了诸如 AlmaLinux、Rocky Linux 等发行版。

CentOS 图标
Arch Linux 分支¶

Arch Linux 是一个基于 x86-64 架构的 Linux 发行版，不过因为其内核默认就包含了部分非自由的模块，所以其未受到 GNU 计划的官方支持。即便如此，Arch Linux 也因其“简单、现代、实在、人本、万能”的宗旨赢得了 Linux 中坚用户的广泛青睐。不过，Arch Linux 对这个宗旨的定义和其它发行版有所区别。通常的操作系统为了方便用户快速上手，都是尽可能隐藏底层细节，从而避免用户了解操作系统的运行知识即可直接使用。但是 Arch Linux 则是重在构建优雅、极简的代码结构，这方便了使用者去理解系统，但不可避免地要求使用者自身愿意去了解操作系统的运作方式。某种程度上说，它的“简单”和“人本”注重的是方便用户通过了解而去最大化地利用它，而不是采取屏蔽工作原理的方式来降低使用门槛。因此，本书不建议初学者直接上手 Arch Linux，但十分推荐在读者对 Linux 有进一步了解之后去探索它。

Arch Linux 图标

Arch Linux 拥有强大的功能，但因其特殊的理念使得用户不易使用。为了能让一般用户也能用上 Arch Linux 的强大功能，它的变种 Manjaro 发行版于 2011 年问世。Manjaro 发行版基于 Arch Linux，但更注重易用，因而更适合一般用户。

Manjaro 图标

以上是若干个常见的 Linux 发行版系列，其他的常用发行版有 openSUSE、Gentoo 等，相关介绍可参考附录中对应的资料。

由上文可见，Linux 的发行版非常丰富，不同的发行版有其各自的特性，因而可以面向不同的用户满足独特的需求。对于新手来说，一个拥有丰富的图形界面的发行版更加适合初步探索和后续使用。本书推荐初次接触 Linux 的读者优先采用 Ubuntu 发行版或者它的子发行版（Lubuntu, Xubuntu 等） 作为自己接触和探索 Linux 的平台，在以后可以自行上手其它发行版。
-->

---
layout: quote
---

# Linux 安装

- cygwin/mingw
- wsl (Windows Sub Linux)
- Linux 虚拟机
- ~~把 Windows 删了~~

<!--
让自己的计算机用上 Linux¶

有很多尚未接触过 Linux 的读者看到这里可能已经在期待或者计划让自己尽快开始使用 Linux 了。事实上，如果把 Linux 看作一个领域，那它的确是一个重视实践的领域。而且出于学习目的，在阅读本书未来的章节时在手头准备一个随时可用的 Linux 发行版是十分关键和有益的。因此，本书强烈建议各位读者在本机安装一个属于自己的 Linux 发行版，以供随时实践。

在本机上安装一个 Linux 发行版有很多种选择，如：安装方法可以选择实机安装或虚拟机安装；发行版则可以在诸多选项中任意抉择。然而，对于新手来说，本书不建议直接采用实机安装 Linux，因为这样做会面临以下问题：

    在安装过程中不理解关键的选项（如：磁盘分区、挂载、交换空间分配等）的意义，很容易做出错误的决定；
    错误的配置可能导致自己原先本机上的操作系统和数据遭到不可逆转的损坏；
    部分硬件可能对安装的发行版缺少兼容，从而导致意外安装失败。
    如果安装的过程中选择下载附加工具，可能会因为默认镜像在国外而导致下载十分缓慢，从而让安装流程变得很漫长。

鉴于以上问题对于新手来说十分常见，本书的编写组为各位读者专门提供了另外一种更为安全高效的方法：在虚拟机上运行 Linux 发行版镜像。虚拟机简单来说可以视作一个安全可靠的沙盒，它受到虚拟机管理软件的管理，而管理软件是直接安装在自己目前常用的操作系统上的。本书推荐使用虚拟机运行安装完毕的 Linux 镜像，因为这样会有如下优点：

    读者仍然可以安心地使用自己当前的操作系统，因为虚拟机不干涉当前电脑操作系统的配置。
    无需考虑底层硬件的兼容性问题，稳定性大幅提升。
    系统已经安装完毕，使用虚拟机打开时相当于直接开机，无需经历安装流程。
    如果在虚拟机中发生任何错误，可以通过重置、回溯虚拟机镜像的方法无痛修复，而不会伤害到读者计算机上的操作系统和数据。

因此，本书将主要讲解如何为自己搭建一个安全高效的 Linux 虚拟机。如果你有一台远程的 Linux 服务器，可以参考拓展阅读的内容配置 SSH 连接。
-->

---

# Shell (命令行环境)

最直接的和内核进行交互的方法  
有多种 shell 可以选择： bash、zsh、fish...

最基本的命令组成:

```shell
command args1 args2 args3...
```

在 Linux 系统中，英文大小写字母是不一样的  
命令、参数、选项以空格区分（不论空几行 shell 都视为一格）  
一般来说，`-{x}`或者`--{x_fullname}`表示这个命令的选项  

**第一个被输入的字符绝对是命令（可执行文件）**

<!--
使用命令行操作可以减少鼠标操作，我们经常可以使用一条命令来代替好几次的鼠标单击。例如如果我们想要移动某一个文件，我们要执行下面步骤：

    打开文件所在的文件夹 ../source/
    打开目标文件夹 ../dest/
    从 ../source/ 文件夹拖拽文件 file.txt 到 ../dest/ 文件夹中

然而使用命令行，我们只需要执行一条指令。

$ mv ../source/file.txt ../dest/

可能在初学者看来，熟记这条指令并不容易，但是从长远上看，熟悉了命令行之后再加上有自动补全的 shell 程序，使用命令行可以节省大量时间。

节省资源¶

图形界面对资源的消耗是不可忽略的，在绝大部分的服务器中都没有使用图形界面，节约资源。
进行高级的系统维护工作¶

一些高级的系统维护任务只能通过命令行来完成，因为相关的程序并没有提供图形界面的控制面板，或者需要手工编写复杂的配置文件。

-->

## 这是怎么来的？

<br>

```c
int main (int argc, char* argv[]) {}
// argc 是你传进去的参数数量
// argv 是你传进去的参数的二级指针
```

<!--
shell 是什么？

如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（GUI），语音输入甚至是 AR/VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell

几乎所有您能够接触到的平台都支持某种形式的 shell，有些甚至还提供了多种 shell 供您选择。虽然它们之间有些细节上的差异，但是其核心功能都是一样的：它允许你执行程序，输入并获取某种半结构化的输出。

本节课我们会使用 Bourne Again SHell, 简称 “bash” 。 这是被最广泛使用的一种 shell，它的语法和其他的 shell 都是类似的。打开 shell 提示符（您输入指令的地方），您首先需要打开 终端 。您的设备通常都已经内置了终端，或者您也可以安装一个，非常简单。
使用 shell

当您打开终端时，您会看到一个提示符，它看起来一般是这个样子的：

missing:~$ 

这是 shell 最主要的文本接口。它告诉你，你的主机名是 missing 并且您当前的工作目录（”current working directory”）或者说您当前所在的位置是 ~ (表示 “home”)。 $ 符号表示您现在的身份不是 root 用户（稍后会介绍）。在这个提示符中，您可以输入 命令 ，命令最终会被 shell 解析。最简单的命令是执行一个程序：

missing:~$ date
Fri 10 Jan 2020 11:49:31 AM EST
missing:~$ 

这里，我们执行了 date 这个程序，不出意料地，它打印出了当前的日期和时间。然后，shell 等待我们输入其他命令。我们可以在执行命令的同时向程序传递 参数 ：

missing:~$ echo hello
hello

上例中，我们让 shell 执行 echo ，同时指定参数 hello。echo 程序将该参数打印出来。 shell 基于空格分割命令并进行解析，然后执行第一个单词代表的程序，并将后续的单词作为程序可以访问的参数。如果您希望传递的参数中包含空格（例如一个名为 My Photos 的文件夹），您要么用使用单引号，双引号将其包裹起来，要么使用转义符号 \ 进行处理（My\ Photos）。

但是，shell 是如何知道去哪里寻找 date 或 echo 的呢？其实，类似于 Python 或 Ruby，shell 是一个编程环境，所以它具备变量、条件、循环和函数（下一课进行讲解）。当你在 shell 中执行命令时，您实际上是在执行一段 shell 可以解释执行的简短代码。如果你要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去咨询 环境变量 $PATH，它会列出当 shell 接到某条指令时，进行程序搜索的路径：

missing:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
missing:~$ which echo
/bin/echo
missing:~$ /bin/echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

当我们执行 echo 命令时，shell 了解到需要执行 echo 这个程序，随后它便会在 $PATH 中搜索由 : 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行（假定该文件是 可执行程序，后续课程将详细讲解）。确定某个程序名代表的是哪个具体的程序，可以使用 which 程序。我们也可以绕过 $PATH，通过直接指定需要执行的程序的路径来执行该程序
在 shell 中导航

shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 / 分割，而在 Windows 上是 \。路径 / 代表的是系统的根目录，所有的文件夹都包括在这个路径之下，在 Windows 上每个盘都有一个根目录（例如： C:\）。 我们假设您在学习本课程时使用的是 Linux 文件系统。如果某个路径以 / 开头，那么它是一个 绝对路径，其他的都是 相对路径 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 pwd 命令来获取。此外，切换目录需要使用 cd 命令。在路径中，. 表示的是当前目录，而 .. 表示上级目录：

missing:~$ pwd
/home/missing
missing:~$ cd /home
missing:/home$ pwd
/home
missing:/home$ cd ..
missing:/$ pwd
/
missing:/$ cd ./home
missing:/home$ pwd
/home
missing:/home$ cd missing
missing:~$ pwd
/home/missing
missing:~$ ../../bin/echo hello
hello

注意，shell 会实时显示当前的路径信息。您可以通过配置 shell 提示符来显示各种有用的信息，这一内容我们会在后面的课程中进行讨论。

一般来说，当我们运行一个程序时，如果我们没有指定路径，则该程序会在当前目录下执行。例如，我们常常会搜索文件，并在需要时创建文件。

为了查看指定目录下包含哪些文件，我们使用 ls 命令：

missing:~$ ls
missing:~$ cd ..
missing:/home$ ls
missing
missing:/home$ cd ..
missing:/$ ls
bin
boot
dev
etc
home
...

除非我们利用第一个参数指定目录，否则 ls 会打印当前目录下的文件。大多数的命令接受标记和选项（带有值的标记），它们以 - 开头，并可以改变程序的行为。通常，在执行程序时使用 -h 或 --help 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。例如，ls --help 的输出如下：

  -l                         use a long listing format

missing:~$ ls -l /home
drwxr-xr-x 1 missing  users  4096 Jun 15  2019 missing

这个参数可以更加详细地列出目录下文件或文件夹的信息。首先，本行第一个字符 d 表示 missing 是一个目录。然后接下来的九个字符，每三个字符构成一组。 （rwx）. 它们分别代表了文件所有者（missing），用户组（users） 以及其他所有人具有的权限。其中 - 表示该用户不具备相应的权限。从上面的信息来看，只有文件所有者可以修改（w），missing 文件夹 （例如，添加或删除文件夹中的文件）。为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：x）权限表示。为了列出它的包含的内容，用户必须对该文件夹具备读权限（r）。对于文件来说，权限的意义也是类似的。注意，/bin 目录下的程序在最后一组，即表示所有人的用户组中，均包含 x 权限，也就是说任何人都可以执行这些程序。

在这个阶段，还有几个趁手的命令是您需要掌握的，例如 mv（用于重命名或移动文件）、 cp（拷贝文件）以及 mkdir（新建文件夹）。

如果您想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，请试试 man 这个程序。它会接受一个程序名作为参数，然后将它的文档（用户手册）展现给您。注意，使用 q 可以退出该程序。
-->

---

# Shell （命令行环境）

<Transform :scale="0.73">
<img
border="rounded"
src="/vt220.jpg"
alt=""
/>
</Transform>

---

# Examples

### `ls - list directory contents`

```shell
ls [OPTION]... [FILE]...

ls # 查看当前目录下的文件和文件夹
ls -l dir # 使用列表格式查看 dir 文件夹里的内容
```

### `cd - change working directory`

```shell
cd [dirName]

cd dir1  # 进入 dir1 目录
cd dir1/dir2  # 进入 dir1 下的 dir2 目录
cd ../  # 进入上一级目录
cd ./  # 进入当前目录（好像没啥用啊）
cd -  # 返回之前的一级目录
cd  # 返回当前用户的家目录
```

命令不需要背下来，只需要熟记常用的几个，其他命令都可以在需要的时候查阅 `man/tldr`  
除此之外，在输入命令的过程中，也可以按下`<TAB>`键让 shell 帮我们补全命令  

<!--
`../ ./ / ~ -` 特殊文件
-->

---
layout: quote
---

# 基本操作

## 文件操作

mv、cp、rm、fd、touch、mkdir...  
cat、nano、sed、awk、grep、tail、less...  

## 实用工具

ps、top、wc、xargs、ip、lsusb、curl、tar、7z...  
git、fzf、ripgrep、tldr、tmux...  

## cheatsheet

[cheatsheet](https://phoenixnap.com/kb/wp-content/uploads/2023/11/linux-commands-cheat-sheet-pdf.pdf)

---

# 环境变量

命令执行时的环境所定义的变量  
可以使用`echo ${VairableName}`查看  

## PATH

定义了存放你当前可执行文件的路径  
当你输入一个命令时，shell 会在 PATH 定义的目录下查找同名的可执行文件，
如果没找到，它就会提示类似于这样的错误信息： `zsh: command not found`  

其默认值为`/usr/bin:/usr/local/bin`  

## USER

定义了当前用户的用户名  

---
layout: quote
---

# Linux 输入输出

## `file descripter  (fd)`

每一个进程默认都有 3 个 fd，
分别对应了标准输入 0 `stdin`、标准输出 1 `stdout` 和错误输出 2 `stderr`  

## 重定向

- `>`和`>>`将标准输出重定向到指定的文件中
- `|`管道运算符将上一个命令的标准输出重定向到下一个命令的标准输入中

<!--
标准输入、输出和错误
​

Linux 中有三个标准流：STDIN（标准输入）、STDOUT（标准输出）和 STDERR（标准错误）。这些流用于处理运行程序和命令时的输入、输出和错误消息。

    STDIN 是标准输入流，用于从键盘或另一个程序读取数据。数字 0 表示 STDIN 流。
    STDOUT 是标准输出流，用于显示程序或命令的输出。数字 1 表示 STDOUT 流。
    STDERR 是标准错误流，用于显示错误消息和诊断信息。数字 2 表示 STDERR 流。

默认情况下，STDIN 连接到键盘，而 STDOUT 和 STDERR 连接到终端。这意味着当您在 shell 中运行命令时，输入来自键盘，输出和错误消息显示在终端上。

一个良好的实践是将错误消息与常规输出分开，以便您可以轻松识别和处理错误。但有些程序可能不遵循这种约定，错误消息可能与常规输出混合在一起。
-->

---

# Linux 权限管理

- 用户及用户组
- root 系统管理员

<!--
为何需要「用户」¶

早期的操作系统没有用户的概念（如 MS-DOS），或者有「用户」的概念，但是几乎不区分用户的权限（如 Windows 9x）。而现在，这不管对于服务器，还是个人用户来说，都是无法接受的。

在服务器环境中，「用户」的概念是明确的：服务器的管理员可以为不同的使用者创建用户，分配不同的权限，保障系统的正常运行；也可以为网络服务创建用户（此时，用户就不再是一个有血有肉的人），通过权限限制，以减小服务被攻击时对系统安全的破坏。

而对于个人用户来说，他们的设备不会有第二个人在使用。此时，现代操作系统一般区分使用者的用户与「系统用户」，并且划分权限，以尽可能保证系统的完整性不会因为用户的误操作或恶意程序而遭到破坏。

根用户¶

在前文中我们知道，在使用 apt 安装软件时，我们需要在前面加上 sudo。这可以使我们以根用户 (root) 的身份安装软件。

根用户 / root 用户在 Linux 操作系统中拥有最高的权限，可以对系统做任何操作（包括删除所有系统文件这一类极端危险的操作）。root 用户的用户数据存储在 /root 下。

在我们使用 sudo 的时候，输入自己的密码并验证正确之后，sudo 就会以 root 用户的身份，执行后面我们希望执行的命令。而使用 apt 安装的软件存储在了系统的目录下，所以必须要以 root 用户的身份安装。这就是我们平时需要 sudo 来安装软件的原因。

系统用户¶

除了你、root 和其他在用你的电脑/服务器的人（如果有）以外，剩下还有很多用户，如 nobody, www-data 等。它们由系统或相关程序创建，用于执行服务等系统任务。不要随意删除这些用户，以免系统运行出现问题。

普通用户¶

普通用户可以登录系统，并对自己的家目录下的文件进行操作。所有普通用户的家目录都在 /home/ 下，位于 /home/username/ 的位置，其中 username 是用户名。

普通用户无法直接修改系统配置，也无法为系统环境安装或卸载软件。
-->

## 切换用户/以某个用户的身份执行命令

- `su` 切换用户，一般会要求输入对应用户的密码
- `sudo` 以某个用户的权限执行命令

<br>

::card
Linux 下的根用户(root)拥有对系统的最高权限，请谨慎使用！  
常见的可能对系统造成毁灭性破坏的命令:

```shell
rm -rf /  # 删除系统上所有文件，包括系统本身
dd if=/dev/urandom of=/dev/sda  # 使用随机数填满 sda 磁盘
:(){ :|: & };:  # fork bomb，通过不断 fork 自身消耗完所有的系统资源
```

::

<!--
早期的操作系统没有用户的概念（如 MS-DOS），
或者有「用户」的概念，但是几乎不区分用户的权限（如 Windows 9x）。
而现在，这不管对于服务器，还是个人用户来说，都是无法接受的。

在服务器环境中，
「用户」的概念是明确的：服务器的管理员可以为不同的使用者创建用户，分配不同的权限，保障系统的正常运行；
也可以为网络服务创建用户（此时，用户就不再是一个有血有肉的人），通过权限限制，以减小服务被攻击时对系统安全的破坏。

而对于个人用户来说，他们的设备不会有第二个人在使用。
此时，现代操作系统一般区分使用者的用户与「系统用户」，并且划分权限，
以尽可能保证系统的完整性不会因为用户的误操作或恶意程序而遭到破坏。

官方软件源镜像¶

通过 apt 安装的软件都来源于相对应的软件源，每个 Linux 发行版一般都带有官方的软件源，在官方的软件源中已经包含了丰富的软件，apt 的软件源列表在 /etc/apt/sources.list 下。
查看本地的软件源列表

Ubuntu 官方源位于国外，往往会有速度与延迟上的限制，可以通过修改官方源为其镜像实现更快的下载速度。

镜像缓存了官方源中的软件列表，与官方源基本一致。

修改官方源为镜像，加快更新速度

本例以修改官方源为 USTC Mirror 为例2。注意：在操作前请做好备份。

一般情况下，/etc/apt/sources.list 下的官方源地址为 http://archive.ubuntu.com/ ，我们只需要将其替换为 http://mirrors.ustc.edu.cn 即可。

如果你使用 Ubuntu 图形安装器安装，默认的源地址通常不是 http://archive.ubuntu.com/ ， 而是 http://<country-code>.archive.ubuntu.com/ubuntu/ ，如 http://cn.archive.ubuntu.com/ubuntu/，同样也将其替换为 http://mirrors.ustc.edu.cn 即可。

可以使用如下命令：

$ sudo sed -i 's|//.*archive.ubuntu.com|//mirrors.ustc.edu.cn|g' /etc/apt/sources.list

当然也可以直接使用 vim、nano 等文本编辑器进行修改。
第三方软件源¶

有时候，由于种种原因，官方软件源中并没有我们需要的软件，但是第三方软件提供商可以提供自己的软件源。在将第三方软件源添加到 /etc/apt/sources.list 中之后，就可以获取到第三方提供的软件列表，再通过 apt install package-name 安装我们需要的第三方软件。你一般可以在需要的第三方软件官网找到这样的配置说明。

-->

---

# 在 Linux 下安装软件

推荐使用系统的包管理器  

## 配置南邮镜像源

[官方教程](https://mirrors.njupt.edu.cn/help/ubuntu/)

<br>

## 安装软件包

<br>

```shell
sudo apt update  # 更新本地软件包索引
sudo apt install xyz  # 安装 xyz 软件包
sudo apt search xyz  # 全局搜索某个软件包
```

<!--
为了方便讲述，本章下文中我们都将以 apt 作为典型实例进行讲解。

apt 的全称是 Advance Package Tool，
是一个处理在 Debian、Ubuntu 或者其他衍生发行版的 Linux 上安装和移除软件的自由软件。

apt 可以自动下载、配置和安装二进制或者源代码格式的软件包，简化了在这些发行版上管理软件的流程。
因此，它常常用来安装软件、自动处理软件包之间的依赖关系、升级软件包以至升级发行版，自动处理升级发行版所需的依赖关系等等。

此外用户可以自定义软件源（软件仓库），自由地添加第三方源来安装官方软件源中没有的软件或者安装特定版本的软件。
-->

---
layout: quote
---

# 开源历史和开源精神

强烈推荐阅读《大教堂与集市》~~开源软件的圣经~~，读完后，你会对开源和黑客文化有一个更深的入的理解。  

**开源 不等于 开放源代码!**

<br>

如果我说软件不一定长得像一个牛皮藓，不一定有启动摇一摇广告，
不一定把所有功能都挤在某个边边角角里？  

> “自由软件”尊重用户的自由，并且尊重整个社区。  
> 粗略来讲，一个软件如果是自由软件，
> 这意味着用户可以自由地运行，拷贝，分发，学习，修改并改进该软件。  
> 因此，“自由软件”是关乎自由的问题，与价格无关。

---

# 使用自由软件 

自由软件现在更加重要  

<br>

::card
使用自由软件，用户控制程序，无论是单个用户还是集体用户。  
所以他们控制着计算机做什么（假设计算机是听话的并且按照用户的程序来执行）。  
使用专有软件，软件控制用户，而其他实体（开发者或“所有者”）控制程序。
所以专有软件赋予开发者凌驾于其用户之上的权力。  
这本身就不公平；甚而，这个权力会诱使其开发者用其他方法损害用户。  
即使专有软件不是完全的恶意，其开发者也有动机使之容易成瘾、有控制权和受操控。  
你会说，就像该文章的作者一样，开发者有道义不那么做，但是一般他们都会被利益驱使。
如果你不想看到这些，那么请确保程序被其用户控制。  
自由就意味着能够控制自己的生活。
如果你用一款软件去实现你生活中的活动，你的自由就依赖于对这款软件的控制权。
你有权拥有你所使用的软件的控制权，当你用它们来做重要事情是则更是如此。  
::

---
layout: two-cols
---

# 一些学习资料

有时间就要学习 xD

- [USTC Linux101](https://101.ustclug.org/)
- [进一步了解 GNU!](https://www.gnu.org/)
- [大教堂与集市](https://github.com/thuwyh/The-Cathedral-the-Bazaar-zh/blob/master/%E5%A4%A7%E6%95%99%E5%A0%82%E4%B8%8E%E9%9B%86%E5%B8%82.md)
- [Linux Atonomy](https://personalpages.manchester.ac.uk/staff/m.dodge/cybergeography/atlas/linux_anatomy.pdf)
- [The art of Commandline](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md)
- [missing semester](https://missing-semester-cn.github.io/)
- [linux command cheatsheet](https://phoenixnap.com/kb/wp-content/uploads/2023/11/linux-commands-cheat-sheet-pdf.pdf)

::right::

<br>

<Transform :scale="0.5">
<img
class="absolute top-100px left-250px"
border="rounded"
src="/qrcode.png"
alt=""
/>
</Transform>

---
layout: end
---

# Thanks!
